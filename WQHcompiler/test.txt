#include<stdio.h>
#include<memory.h>
int total_count, local_count, failed_count;
char* test_class;
//支持前向声明
void test(int actual, int expected);
void Complex_Expression();
void test_address_dereference();
void Enum();
void test_recursive();
int fibonacci(int i);
void test_control_flows();
void test_struct_union();
int main()
{
	Complex_Expression();
	test_address_dereference();
	Enum();
	test_recursive();
	test_control_flows();
	test_struct_union();
	test_struct_union();
	printf("total: %d, passed: %d, failed: %d\n", total_count, total_count - failed_count, failed_count);
	return 0;
}
void test(int actual, int expected)//测试输入的值是否与预期值相同
{
	if (actual != expected)
		failed_count++;
	printf("test %3d %s (test for %s %2d), ",
		total_count++, (expected == actual ? "passed" : "failed"), test_class, local_count++);
	printf("expected: %d, actual: %d%s\n", expected, actual, expected != actual ? " ============> failed" : "");
}
void Complex_Expression()//测试表达式
{
	int x, a, b, c, result;
	test_class = (char*)"Complex_Expression";
	a = 0x3f9ab;
	b = 6;
	c = 7;
	x = ((((5 > 6 ? 5 : 6) * 5 + 7) / 3) + 5 && 6 && 7 + 5 || 6 && (!7)) * (5 + 6 * 7);
	test(x, 47);
	result = (a + a != b + b * c > 15 ? (b | a) ? a | c : !b : (c & a) && (c >= 3 || a <= 8) + a % b << 2 == 0) ^ a--;
	test(result, 4);
	printf("\n");
}
void test_address_dereference()//测试指针与指针解引用
{
	int a, * p, ** pp, *** ppp;
	test_class = (char*)"address and dereference";
	local_count = 1;
	a = 0;
	p = &a;
	pp = &p;
	ppp = &pp;//多少层指针都可以
	test((int)p, (int)&a);
	test((int)pp, (int)&p);
	test((int)ppp, (int)&pp);
	test(*p, a);
	test((int)*pp, (int)p);
	test((int)*ppp, (int)pp);
	test((int)*&p, (int)p);
	test(**&p, a);
	test(***ppp, a);
	printf("\n");
}
enum { First = 10, Second, Third = 1000, Fourth };
enum named { First1, Second1, Third1, Fourth1 };
enum TestStatusEnum { GoodStatus = 1, BadStatus = 100, NotSureStatus, AreYouSureStatus, AreYouSeriousStatus, };
enum TestStatusEnum status;
enum TestStatusEnum getBossStatus(enum TestStatusEnum input)
{
	if (input == GoodStatus || input == BadStatus)
		return AreYouSureStatus;
	else if (input == NotSureStatus)
		return AreYouSeriousStatus;
	else
		return BadStatus;
}
void Enum()//测试枚举类型
{
	enum TestStatusEnum myStatus;
	test_class = (char*)"enum";
	local_count = 1;
	//测试枚举作函数参数，返回值,强转成int,sizeof
	myStatus = GoodStatus;
	test(getBossStatus(myStatus), AreYouSureStatus);
	test(getBossStatus(NotSureStatus), AreYouSeriousStatus);
	status = (enum TestStatusEnum)102;
	test(status, AreYouSureStatus);
	test(sizeof(enum TestStatusEnum), sizeof(int));
	printf("\n");
	//测试枚举值是否与整型相同
	
	test(First, 10);
	test(Second, 11);
	test(Third, 1000);
	test(Fourth, 1001);

	test(First1, 0);
	test(Second1, 1);
	test(Third1, 2);
	test(Fourth1, 3);
		printf("\n");
}
void test_recursive()//测试递归
{
	test_class = (char*)"recursive";
	local_count = 1;

	test(fibonacci(0), 0);
	test(fibonacci(10), 55);
	printf("\n");
}
int fibonacci(int i)
{
	if (i <= 0)
		return 0;
	if (i == 1)
		return 1;
	return fibonacci(i - 1) + fibonacci(i - 2);
}
void test_control_flows()//测试控制流
{
	int i;
	int result;

	// while
	test_class = (char*)"conditionals while";
	local_count = 1;
	i = 0;
	result = 0;
	while (i <= 100)
	{
		result = result + i++;
	}
	test(result, 5050);
	printf("\n");

	// if-else
	test_class = (char*)"conditionals if-else";
	local_count = 1;
	i = 0;
	result = 0;
	while (i <= 100)
	{
		if (i % 4 == 0)
		{
			result = result + i;
		}
		else if (i % 4 == 1)
		{
			result = result - i;
		}
		else if (i % 4 == 2)
		{
			result = result + 2 * i;
		}
		else
			;
		i++;
	}
	test(result, 2575);
	printf("\n");

	test_class = (char*)"conditionals for";
	local_count = 1;

	// test for
	for (i = result = 0; i <= 100; i++)
	{
		result = result + i;
	}
	test(result, 5050);
	// 缺省 for
	result = 0;
	i = 0;
	for (; i <= 100;)
	{
		result = result + i++;
	}
	test(result, 5050);
	printf("\n");

	// do-while
	test_class = (char*)"conditionals do while";
	local_count = 1;
	i = 0;
	result = 0;
	do
	{
		result = result + i;
		i++;
	} while (i <= 100);
	test(result, 5050);
	printf("\n");

	// break in for
	test_class = (char*)"conditionals break";
	local_count = 1;
	for (i = result = 0; i < 200; i++)
	{
		result = result + i;
		if (i == 100)
			break;
	}
	test(result, 5050);
	printf("\n");

	// continue in while
	test_class = (char*)"conditionals continue";
	i = result = 0;
	while (i <= 100)
	{
		i++;
		if (i > 10)
			continue;
		result = result + i;
	}
	test(result, 55);
	printf("\n");

	// test goto
	i = result = 0;

	test_class = (char*)"conditionals goto & label";
	local_count = 1;
start:
	if (i > 100)
		goto end;
	result = result + i;
	i++;
	goto start;
end:
	test(result, 5050);
	printf("\n");


}
// forward declaration
union Variant;

struct Matrix
{
	// just test, no meaning
	int m11, m12, m21, m22;
	int flag;
	struct Matrix* ma;
	union Variant* p;
};

union Variant
{
	int i;
	char c;
	struct Matrix m;
	void* p;
};

// global
struct Matrix m;
union Variant v;

void test_struct_union()
{
	// local
	union Variant v;
	struct Matrix* m_list;
	struct Matrix* tmpm;

	test_class = (char*)"union and struct";
	local_count = 1;

	v.p = &v;//基本的成员赋值测试
	test((int)v.p, (int)&v);
	v.i = 0x798D145F;
	test(v.i, 0x798D145F);
	v.c = 'c';
	test(v.c, 'c');
	printf("\n");

	v.m.flag = 100;//测试联合体内嵌结构体
	test(v.m.flag, 100);
	v.m.ma = &v.m;
	test((int)v.m.ma, (int)&v.m);
	printf("\n");

	test_class = (char*)"union and struct operator . ->";
	local_count = 1;

	// operator . ->
	v.m.m11 = 1;
	v.m.m12 = 2;
	test(v.m.m11, 1);
	test(v.m.m12, 2);
	printf("\n");

	(&v)->m.m11 = 100;//& . 的正常使用
	(&v.m)->m12 = 200;
	(&(&v)->m)->m21 = 300;
	*&v.m.m22 = 400;
	test(v.m.m11, 100);
	test(v.m.m12, 200);
	test(v.m.m21, 300);
	test(v.m.m22, 400);
	printf("\n");

	// ++ -- + - []
	test_class = (char*)"union and struct pointer operator ++/--/+/-/[]";
	local_count = 1;

	m_list = 0;
	m_list = (struct Matrix*)malloc(sizeof(struct Matrix) * 100);//malloc的支持
	
	test(m_list, (int)&m_list[0]);
	test(&m_list[1], m_list + 1);
	test(&m_list[10], m_list + 10);
	printf("\n");

	// sizeof
	test_class = (char*)"union and struct operator sizeof";
	local_count = 1;
	test(sizeof(union Variant), sizeof(struct Matrix));
	printf("\n");
}



